<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jeu de Lecture - Fluence CE1</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Andika&family=Fredoka:wght@400;600&display=swap');
        
        body {
            font-family: 'Andika', sans-serif;
            background-color: #000000;
            color: #ffffff;
            overflow-x: hidden;
        }

        h1, h2, h3, button, input, textarea {
            font-family: 'Fredoka', sans-serif;
        }

        .word {
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            display: inline-block;
            margin: 0 0.2em;
            padding: 0.1em 0.2em;
        }

        .word-future {
            color: #ffffff;
            opacity: 0.4;
        }

        /* Scale 1 (taille normale) pour le mot courant, juste en blanc brillant */
        .word-current {
            color: #ffffff;
            opacity: 1;
            transform: scale(1); 
            font-weight: bold;
            z-index: 10;
        }

        .word-past-correct {
            color: #9ca3af; /* Gris moyen */
            opacity: 0.6;
            transform: scale(1);
        }

        .word-past-skipped {
            color: #4b5563; /* Gris fonc√© */
            opacity: 0.4;
            transform: scale(0.9);
            font-style: italic;
        }

        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }

        .fade-in {
            animation: fadeIn 0.5s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const IconBase = ({ children, size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                {children}
            </svg>
        );

        const Mic = (props) => (
            <IconBase {...props}>
                <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/>
                <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
                <line x1="12" y1="19" x2="12" y2="23"/>
                <line x1="8" y1="23" x2="16" y2="23"/>
            </IconBase>
        );

        const Home = (props) => (
            <IconBase {...props}>
                <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/>
                <polyline points="9 22 9 12 15 12 15 22"/>
            </IconBase>
        );

        const BookOpen = (props) => (
            <IconBase {...props}>
                <path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/>
                <path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/>
            </IconBase>
        );

        const Edit = (props) => (
             <IconBase {...props}>
                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
            </IconBase>
        );

        const Save = (props) => (
             <IconBase {...props}>
                <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                <polyline points="17 21 17 13 7 13 7 21"></polyline>
                <polyline points="7 3 7 8 15 8"></polyline>
            </IconBase>
        );

        const INITIAL_LEVELS = [
            {
                id: 'niv1',
                name: 'Parcours 4 : texte 1 et 2',
                color: 'bg-green-900 border-green-700 text-green-100',
                texts: [
                    { id: 101, title: "Une soupe pour Boucle d‚ÄôOr", content: "Pendant ce temps, une petite fille appel√©e Boucle d‚ÄôOr arriva par hasard devant leur maison. Comme elle √©tait curieuse, elle regarda par la fen√™tre, puis par le trou de la serrure. Et, ne voyant personne, elle souleva le loquet. La porte n‚Äô√©tait pas ferm√©e. Boucle d‚ÄôOr ouvrit la porte et entra.
Sur la table, il y avait trois bols remplis de bouillie : un tr√®s grand bol, un bol moyen, et un tout petit bol. Boucle d‚ÄôOr go√ªta d‚Äôabord la bouillie du grand gros ours, mais elle la trouva trop chaude. Puis elle go√ªta la bouillie de l‚Äôours moyen, mais elle la trouva trop froide. Alors elle go√ªta la bouillie du tout petit ours.
Elle n‚Äô√©tait ni trop chaude ni trop froide ; juste comme il fallait. Et Boucle d‚ÄôOr la trouva si bonne qu‚Äôelle la mangea tout enti√®re." },
                    { id: 102, title: "Jour de p√™che", content: "√Ä c√¥t√© de la rivi√®re, il y a un tracteur et sa remorque. Sidonie est trop curieuse. Elle soul√®ve la b√¢che : et l√†‚Ä¶ elle voit des paniers pleins de fruits. Elle s‚Äôassoit dans la remorque et commence √† d√©guster une belle poire. Mais tout √† coup, vroum‚Ä¶ le tracteur d√©marre. EtSidonie n‚Äôa pas le temps de descendre. 
Elle s‚Äôaccroche √† la b√¢che pour ne pas tomber. Mais vraiment, c‚Äôest tr√®s dangereux ! Oh ! Une dame sur le bord de la route. Alors Sidonie l√®ve le bras pour l‚Äôappeler au secours. Mais la dame n‚Äôa pas compris, elle lui fait coucou... Oh ! Ici, un petit gar√ßon. Sidonie lui crie : ¬´ Sauve-moi ! ¬ª Mais le petit gar√ßon malpoli lui tire la langue. 
Ouf‚Ä¶ Sidonie voit un gendarme. Lui, il saura quoi faire ! Malheureusement le gendarme ne regarde pas dans la bonne direction‚Ä¶ Alors, vite, Sidonie prend une des poires d‚Äôun panier et la lance vers le gendarme. Catastrophe ! la poire s‚Äô√©crase sur son nez‚Ä¶" }
                ]
            },
            {
                id: 'niv2',
                name: 'Parcours 4 : texte 3 et 4',
                color: 'bg-blue-900 border-blue-700 text-blue-100',
                texts: [
                    { id: 201, title: "Que de parfums !", content: "¬´ Fraise, menthe, vanille, chocolat ? ¬ª nous demande-t-elle. Mon grand fr√®re Jules opte tout de suite pour un cornet menthe-chocolat. Moi, j‚Äôh√©site. Je me hisse sur la pointe des pieds pour voir la vitrine. Il y a huit bacs, mais Maman n‚Äôa cit√© que quatre parfums. 
Que proposent les quatre autres ? Noix de coco ? Mangue ? Passion ? Caramel ? Ces go√ªts-l√† me tenteraient bien. Maman me presse : des clients attendent derri√®re nous. Ind√©cise, je jette un ≈ìil sur mon doudou cochon, et la couleur de son pelage me renvoie au bac rose face √† moi. ¬´ Fraise ! ¬ª je lance. 
J'attrape le cornet que me tend le marchand et donne un grand coup de langue sur le sorbet. C'est bon, c'est frais." },
                    { id: 202, title: "Le gar√ßon qui criait ¬´ AU LOUP ¬ª !", content: "Un jour que Louis faisait un tour dans la montagne, le loup bondit de derri√®re un rocher.
‚Äì Au loup ! hurla Louis. Et il courut vers le village en criant : 
‚Äì Au loup ! Au loup ! Mais sa grand-m√®re ne le crut pas. 
‚Äì Tu racontes tout le temps la m√™me chose ! Change de refrain ! dit-elle.
‚Äì Au loup ! criait toujours Louis. Mais personne ne l‚Äô√©coutait.
‚Äì Au secours ! hurlait le pauvre gar√ßon. Tout le monde riait. 
‚Äì Tu te moques encore de nous ! lui dirent les grandes personnes. Le loup rattrapa Louis. Alors les grandes personnes dirent au gar√ßon : 
‚Äì Cela t‚Äôapprendra √† dire des mensonges !" }
                ]
            },
            {
                id: 'niv3',
                name: 'Parcours 4 : texte 5',
                color: 'bg-purple-900 border-purple-700 text-purple-100',
                texts: [
                    { id: 301, title: "MysteÃÄre aÃÄ la p√¢tisserie", content: "Son magasin avait √©t√© sauvagement saccag√©. Les vitres √©taient bris√©es et il n‚Äôy avait plus un seul g√¢teau sur les plateaux o√π elle les avait d√©pos√©s la veille au soir. Le sol √©tait couvert de d√©bris de verre, de brioches √©cras√©es, macul√© de cr√®me p√¢tissi√®re, affreusement souill√© de mousse au chocolat.
Sur cette immonde marmelade, Madame Leroi, terrifi√©e, distingua nettement des empreintes‚Ä¶ Elle hurla.En entendant son cri, Monsieur Pierrot, le propri√©taire du caf√© d‚Äôen face, se pr√©cipita √† son secours. Arriv√© sur le seuil de la boutique, il re√ßut dans ses bras Madame Leroi √©vanouie, mais il la l√¢cha aussit√¥t : il avait vu les empreintes.
√Ä la m√™me heure on entendit des cris d'√©pouvante rue de la R√©publique puis place Du Breuil, c'est-√†-dire dans trois autres p√¢tisseries." },
                    { id: 302, title: "Nuit sous la tente", content: "L'√©t√©, Sarah et son papa dorment dans le jardin. Ils montent une tente verte sous le grand arbre. La nuit, ils √©coutent les hiboux et regardent les √©toiles. Sarah n'a pas peur du noir avec sa lampe de poche." }
                ]
            }
        ];

        const normalize = (str) => {
            return str.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, "").trim();
        };

        const App = () => {
            const [levels, setLevels] = useState(INITIAL_LEVELS);
            const [view, setView] = useState('levels');
            const [selectedLevelId, setSelectedLevelId] = useState(null);
            const [selectedText, setSelectedText] = useState(null);
            const [words, setWords] = useState([]);
            const [currentIndex, setCurrentIndex] = useState(0);
            const [isListening, setIsListening] = useState(false);
            const [startTime, setStartTime] = useState(null);
            const [results, setResults] = useState([]);
            const [isEditing, setIsEditing] = useState(false);
            
            const recognitionRef = useRef(null);
            const currentWordRef = useRef(null);
            const currentIndexRef = useRef(0);
            const wordsRef = useRef([]);

            const getCurrentLevel = () => levels.find(l => l.id === selectedLevelId);

            useEffect(() => { currentIndexRef.current = currentIndex; }, [currentIndex]);
            useEffect(() => { wordsRef.current = words; }, [words]);

            // ALGORYTHME DE CORRESPONDANCE AM√âLIOR√â (VERBES EN -ENT)
            const isMatch = (spoken, target) => {
                if (!spoken || !target) return false;
                
                // Correspondance exacte
                if (spoken === target) return true;
                
                // Si la cible contient ce qui est dit (ex: "mangent" contient "mange")
                // On ajoute une s√©curit√© de longueur pour √©viter que "a" valide "chat"
                if (target.startsWith(spoken) && spoken.length >= 2) return true;
                
                // Cas sp√©cifiques pluriels et verbes muets
                if (target === spoken + 's') return true;
                if (target === spoken + 'x') return true;
                
                // GESTION DES VERBES EN -ENT
                // Ex: Target "mangent" (spoken: "mange") -> "mange" + "nt" = "mangent"
                if (target === spoken + 'nt') return true;
                // Cas o√π l'API renvoie une forme bizarre ou pour couvrir "ent" complet
                if (target === spoken + 'ent') return true;

                return false;
            };

            useEffect(() => {
                if (!isListening) return;

                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                if (!SpeechRecognition) return;

                const recognition = new SpeechRecognition();
                recognitionRef.current = recognition;
                recognition.continuous = true;
                recognition.interimResults = true;
                recognition.lang = 'fr-FR';

                recognition.onresult = (event) => {
                    const transcript = event.results[event.results.length - 1][0].transcript;
                    const spokenWords = transcript.trim().split(/\s+/).filter(w => w.length > 0);
                    
                    let targetIndex = currentIndexRef.current;
                    const targetList = wordsRef.current;

                    for (let spokenWord of spokenWords) {
                        const normalizedSpoken = normalize(spokenWord);
                        
                        // PRIORIT√â AU PR√âSENT ET FUTUR PROCHE POUR √âVITER LES RETOURS EN ARRI√àRE INVOLONTAIRES
                        // Ordre de recherche : 0 (actuel), 1 (suivant), 2 (surlendemain), puis -1 (pr√©c√©dent), etc.
                        const searchOrder = [0, 1, 2, -1, -2, -3, -4, -5];

                        for (let offset of searchOrder) {
                            const lookIndex = targetIndex + offset;
                            
                            // V√©rification des bornes
                            if (lookIndex < 0 || lookIndex >= targetList.length) continue;

                            const target = targetList[lookIndex].clean;
                            
                            // Protection pour √©viter de valider des petits mots n'importe o√π
                            if (offset !== 0 && target.length <= 2) {
                                // On est plus strict sur les petits mots quand on saute ou recule
                                if (spokenWord !== target) continue; 
                            }

                            if (isMatch(normalizedSpoken, target)) {
                                // CAS 1 : AVANCEMENT (Prioritaire)
                                if (offset >= 0) {
                                    // Si on a saut√© des mots (offset > 0), on les marque 'skipped'
                                    if (offset > 0) {
                                        markAs(targetIndex, lookIndex, 'skipped');
                                    }
                                    // On valide le mot actuel
                                    markAs(lookIndex, lookIndex + 1, 'correct');
                                    targetIndex = lookIndex + 1;
                                    break;
                                }
                                
                                // CAS 2 : RETOUR EN ARRI√àRE (Seulement si pas de match devant)
                                if (offset < 0) {
                                    // On valide le mot corrig√©
                                    markAs(lookIndex, lookIndex + 1, 'correct');
                                    // On replace le curseur juste apr√®s ce mot pour que l'√©l√®ve puisse encha√Æner
                                    targetIndex = lookIndex + 1;
                                    break; 
                                }
                            }
                        }
                    }

                    if (targetIndex !== currentIndexRef.current) {
                        setCurrentIndex(targetIndex);
                        if (targetIndex >= targetList.length) finish();
                    }
                };

                recognition.onend = () => {
                    if (isListening && currentIndexRef.current < wordsRef.current.length) {
                        try { recognition.start(); } catch(e) {}
                    }
                };

                try { recognition.start(); } catch(e) {}
                return () => recognition.stop();
            }, [isListening]);

            const markAs = (from, to, status) => {
                setResults(prev => {
                    const newRes = [...prev];
                    for (let i = from; i < to; i++) {
                        // Si on revient en arri√®re pour corriger, on √©crase le statut pr√©c√©dent
                        // Si c'est un saut, on n'√©crase pas un 'correct' d√©j√† acquis
                        if (status === 'correct' || newRes[i] !== 'correct') {
                            newRes[i] = status;
                        }
                    }
                    return newRes;
                });
            };

            useEffect(() => {
                if (currentWordRef.current) {
                    currentWordRef.current.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }, [currentIndex, view]);

            const handleTextUpdate = (textId, field, value) => {
                setLevels(prevLevels => prevLevels.map(level => {
                    if (level.id !== selectedLevelId) return level;
                    return {
                        ...level,
                        texts: level.texts.map(t => t.id === textId ? { ...t, [field]: value } : t)
                    };
                }));
            };

            const startGame = (text) => {
                setSelectedText(text);
                const splitWords = text.content.split(' ').map((w, i) => ({
                    original: w,
                    clean: normalize(w),
                    id: i
                }));
                setWords(splitWords);
                setCurrentIndex(0);
                setResults(new Array(splitWords.length).fill(null));
                setIsListening(false);
                setStartTime(null);
                setView('game');
            };

            const startTimerAndListening = () => {
                setStartTime(Date.now());
                setIsListening(true);
            };

            const finish = () => {
                setIsListening(false);
                if (recognitionRef.current) recognitionRef.current.stop();
                setView('result');
            };

            if (view === 'levels') {
                return (
                    <div className="min-h-screen bg-black text-white p-8 flex flex-col items-center">
                        <h1 className="text-5xl font-black mb-12 text-center bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-green-400">LECTURE FLUIDE</h1>
                        <div className="w-full max-w-md space-y-6">
                            {levels.map(l => (
                                <button key={l.id} onClick={() => {setSelectedLevelId(l.id); setView('textSelection');}} 
                                className={`w-full p-8 rounded-3xl border-2 border-white/10 ${l.color} hover:scale-105 transition-transform text-left shadow-2xl`}>
                                    <h3 className="text-2xl font-bold">{l.name}</h3>
                                    <p className="opacity-70 text-sm">Choisis ton histoire</p>
                                </button>
                            ))}
                        </div>
                    </div>
                );
            }

            if (view === 'textSelection') {
                const currentLevel = getCurrentLevel();
                return (
                    <div className="min-h-screen bg-black text-white p-8 flex flex-col items-center">
                        <div className="w-full max-w-md flex justify-between items-center mb-8">
                            <button onClick={() => setView('levels')} className="opacity-50 hover:opacity-100 flex items-center gap-2">‚Üê Retour</button>
                            <button 
                                onClick={() => setIsEditing(!isEditing)} 
                                className={`flex items-center gap-2 px-4 py-2 rounded-full font-bold transition-colors ${isEditing ? 'bg-yellow-600 text-white' : 'bg-zinc-800 text-zinc-400'}`}
                            >
                                {isEditing ? <><Save size={18}/> Finir</> : <><Edit size={18}/> √âditer</>}
                            </button>
                        </div>

                        <h2 className="text-3xl font-bold mb-8 text-blue-400">{currentLevel.name}</h2>
                        
                        <div className="w-full max-w-md space-y-4">
                            {currentLevel.texts.map(t => (
                                <div key={t.id} className="w-full bg-white/5 border border-white/10 rounded-2xl overflow-hidden transition-colors">
                                    {isEditing ? (
                                        <div className="p-4 flex flex-col gap-3">
                                            <label className="text-xs text-zinc-500 uppercase font-bold">Titre</label>
                                            <input 
                                                type="text" 
                                                value={t.title}
                                                onChange={(e) => handleTextUpdate(t.id, 'title', e.target.value)}
                                                className="bg-black/40 border border-white/20 rounded p-2 text-white font-bold w-full"
                                            />
                                            <label className="text-xs text-zinc-500 uppercase font-bold">Contenu</label>
                                            <textarea 
                                                value={t.content}
                                                onChange={(e) => handleTextUpdate(t.id, 'content', e.target.value)}
                                                className="bg-black/40 border border-white/20 rounded p-2 text-white w-full h-32 text-sm"
                                            />
                                        </div>
                                    ) : (
                                        <button onClick={() => startGame(t)} className="w-full p-6 text-left flex items-center gap-4 hover:bg-white/10">
                                            <BookOpen className="text-green-400 shrink-0" />
                                            <span className="text-xl font-medium">{t.title}</span>
                                        </button>
                                    )}
                                </div>
                            ))}
                        </div>
                    </div>
                );
            }

            if (view === 'game') {
                return (
                    <div className="fixed inset-0 bg-black flex flex-col">
                        <div className="p-4 border-b border-white/10 flex justify-between items-center bg-zinc-900">
                            <button onClick={() => setView('textSelection')} className="text-white/40 hover:text-white">Quitter</button>
                            <span className="font-bold text-white/80">{selectedText.title}</span>
                            <div className="w-10"></div>
                        </div>

                        <div className="flex-1 relative flex flex-col items-center justify-center overflow-hidden">
                            <div className="w-full max-w-[95%] lg:max-w-[90%] h-full overflow-y-auto px-4 md:px-12 py-[40vh] text-center no-scrollbar scroll-smooth">
                                <div className="text-5xl md:text-6xl leading-[2.5] tracking-wide">
                                    {words.map((word, i) => (
                                        <span
                                            key={i}
                                            ref={i === currentIndex ? currentWordRef : null}
                                            className={`word 
                                                ${i < currentIndex ? (results[i] === 'correct' ? 'word-past-correct' : 'word-past-skipped') : ''}
                                                ${i === currentIndex ? 'word-current' : 'word-future'}
                                            `}
                                        >
                                            {word.original}
                                        </span>
                                    ))}
                                </div>
                            </div>
                            <div className="absolute top-0 inset-x-0 h-40 bg-gradient-to-b from-black to-transparent pointer-events-none"></div>
                            <div className="absolute bottom-0 inset-x-0 h-40 bg-gradient-to-t from-black to-transparent pointer-events-none"></div>
                        </div>

                        <div className="p-8 bg-zinc-900 border-t border-white/10 flex flex-col items-center gap-6 shadow-2xl">
                            {!isListening ? (
                                <button onClick={startTimerAndListening} className="bg-white text-black text-2xl font-black px-12 py-5 rounded-full flex items-center gap-4 shadow-white/20 shadow-lg hover:scale-105 transition-transform">
                                    <Mic size={32} /> COMMENCER
                                </button>
                            ) : (
                                <div className="flex gap-4 w-full max-w-lg">
                                    <button 
                                        onClick={() => {
                                            markAs(currentIndex, currentIndex + 1, 'skipped');
                                            setCurrentIndex(prev => prev + 1);
                                            if (currentIndex + 1 >= words.length) finish();
                                        }} 
                                        className="flex-1 bg-white/10 text-white font-bold py-5 rounded-2xl border border-white/10 active:scale-95 transition-transform"
                                    >
                                        Passer le mot
                                    </button>
                                    <button onClick={() => setIsListening(false)} className="bg-red-500/20 text-red-500 font-bold px-8 py-5 rounded-2xl border border-red-500/30">
                                        Pause
                                    </button>
                                </div>
                            )}
                        </div>
                    </div>
                );
            }

            if (view === 'result') {
                const correctCount = results.filter(r => r === 'correct').length;
                const skippedCount = results.filter(r => r === 'skipped').length;
                
                const endTime = Date.now();
                const durationSec = Math.max((endTime - (startTime || endTime)) / 1000, 1);
                const wpm = Math.round((correctCount * 60) / durationSec);

                return (
                    <div className="min-h-screen bg-black flex items-center justify-center p-6">
                        <div className="bg-zinc-900 w-full max-w-lg p-10 rounded-[3rem] border border-white/10 shadow-2xl fade-in">
                            <h2 className="text-4xl font-black text-center mb-10 text-white">R√©sultats üèÜ</h2>
                            
                            <div className="space-y-4 mb-8">
                                <div className="bg-white/5 p-6 rounded-3xl flex justify-between items-center">
                                    <span className="text-white/60 font-bold uppercase text-xs tracking-widest">Fluence (MCLM)</span>
                                    <span className="text-3xl font-black text-blue-400">{wpm} <small className="text-xs">mots/min</small></span>
                                </div>

                                <div className="grid grid-cols-2 gap-4">
                                    <div className="bg-green-500/10 p-6 rounded-3xl border border-green-500/20 flex flex-col items-center">
                                        <p className="text-green-500 text-[10px] font-bold uppercase mb-1">Mots Bien lus</p>
                                        <p className="text-4xl font-black text-green-500">{correctCount}</p>
                                    </div>
                                    <div className="bg-emerald-900/10 p-6 rounded-3xl border border-emerald-700/20 flex flex-col items-center">
                                        <p className="text-emerald-300 text-[10px] font-bold uppercase mb-1">Mots Saut√©s</p>
                                        <p className="text-4xl font-black text-emerald-300 opacity-60">{skippedCount}</p>
                                    </div>
                                </div>
                            </div>

                            <div className="bg-black/60 p-6 rounded-2xl mb-8 border border-white/5 max-h-48 overflow-y-auto">
                                <div className="flex flex-wrap justify-center gap-2 text-lg">
                                    {words.map((w, i) => (
                                        <span key={i} className={results[i] === 'correct' ? 'text-green-500 font-bold' : 'text-emerald-300/30'}>
                                            {w.original}
                                        </span>
                                    ))}
                                </div>
                            </div>

                            <button onClick={() => setView('levels')} className="w-full bg-white text-black font-black py-5 rounded-2xl text-xl hover:bg-zinc-200 transition-colors">
                                Retour au menu
                            </button>
                        </div>
                    </div>
                );
            }
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>


